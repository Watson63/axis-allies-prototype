<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Axis & Allies Prototype — Full Battle UI</title>

  <!-- Vue + Firebase (compat) -->
  <script src="https://unpkg.com/vue@3.4.27/dist/vue.global.prod.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <style>
    body { font-family: sans-serif; margin: 0; background: #f2f2f2; text-align: center; }
    #board { display: grid; grid-template-columns: repeat(5, 100px); gap: 8px; padding: 20px; justify-content: center; }
    .territory { width: 100px; height: 100px; background: white; border: 2px solid #333; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; cursor:pointer; transition: border 0.2s; }
    .territory.selected { border: 3px solid #007bff; box-shadow: 0 0 10px rgba(0,0,255,0.4); }
    .unit { font-size: 11px; padding: 4px 6px; border-radius: 4px; margin: 3px 0; color: white; font-weight: bold; }
    select { margin-top: 10px; padding:5px; font-size:14px; }
    #log { width: 80%; margin: 10px auto; text-align: left; background: #fff; border: 1px solid #ccc; padding: 10px; max-height: 150px; overflow-y: auto; }
    /* Modal */
    .modal-backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:1000; }
    .modal { width: 760px; max-width:95%; background:#fff; border-radius:8px; padding:16px; box-shadow:0 8px 30px rgba(0,0,0,0.3); text-align:left; }
    .battle-row { display:flex; gap:12px; align-items:flex-start; }
    .side { flex:1; border:1px solid #ddd; padding:8px; border-radius:6px; min-height:120px; max-height:320px; overflow:auto; }
    .dice { display:flex; gap:6px; margin:6px 0; flex-wrap:wrap;}
    .die { width:28px; height:28px; display:flex; align-items:center; justify-content:center; border-radius:4px; background:#eee; font-weight:bold; }
    .btn { padding:8px 10px; border-radius:6px; border:none; cursor:pointer; }
    .btn-primary { background:#007bff; color:#fff; }
    .btn-danger { background:#e74c3c; color:#fff; }
    .unit-checkbox { margin-right:6px; transform:scale(1.1); }
    .small { font-size:12px; color:#555; }
  </style>
</head>
<body>
<div id="app">
  <div v-if="!user">
    <h2>Login</h2>
    <input v-model="email" placeholder="Email"><br>
    <input v-model="password" type="password" placeholder="Password"><br>
    <button @click="login">Login / Register</button>
  </div>

  <div v-else>
    <h2>Welcome, {{ user.email }}</h2>

    <div>
      <label><strong>Select Unit Type:</strong></label><br>
      <select v-model="selectedUnitType">
        <option v-for="type in unitTypes" :key="type" :value="type">{{ type }}</option>
      </select>
    </div>

    <div id="board">
      <div
        v-for="id in territoryOrder"
        :key="id"
        class="territory"
        :class="{ selected: selected && selected.from === id }"
        @click="handleTerritoryClick(id)"
      >
        <strong>{{ id }}</strong>
        <div v-for="u in map[id]?.units || []" :key="u.id" class="unit" :style="{ backgroundColor: u.color || '#999' }">
          {{ u.type }}
        </div>
      </div>
    </div>

    <div id="log">
      <h3>Battle Log</h3>
      <div v-for="(entry, i) in battleSummaryLog" :key="i">• {{ entry }}</div>
    </div>
  </div>

  <!-- Battle Modal -->
  <div v-if="activeBattle" class="modal-backdrop">
    <div class="modal">
      <h3>Battle at {{ activeBattle.territory }}</h3>
      <div class="small">Attacker: {{ activeBattle.attackerEmail }} — Defender: {{ activeBattle.defenderEmail }}</div>
      <div style="margin-top:8px;">
        <div class="battle-row">
          <!-- Attacker side -->
          <div class="side">
            <h4>Attacker Units</h4>
            <div v-for="u in activeBattle.attackerUnits" :key="u.id" style="display:flex;align-items:center;justify-content:space-between;margin:4px 0;">
              <div style="display:flex;align-items:center;gap:8px;">
                <div class="unit" :style="{ backgroundColor: u.color }">{{ u.type }}</div>
                <div class="small">{{ u.id }}</div>
              </div>
              <!-- attacker selects casualties when needed -->
              <div v-if="phase === 'chooseDefenderCasualties' || phase === 'chooseAttackerCasualties'">
                <input type="checkbox" class="unit-checkbox" :value="u.id" v-model="selectedCasualtiesAttacker" />
              </div>
            </div>

            <div class="small" style="margin-top:6px;">Attacker Rolls:</div>
            <div class="dice">
              <div v-for="(d,i) in activeBattle.attackerRolls || []" :key="'a'+i" class="die">{{ d }}</div>
            </div>

            <div style="margin-top:8px;">
              <button class="btn btn-primary" :disabled="!canRoll('attacker')" @click="rollDice('attacker')">Roll Dice (Attacker)</button>
            </div>
          </div>

          <!-- Defender side -->
          <div class="side">
            <h4>Defender Units</h4>
            <div v-for="u in activeBattle.defenderUnits" :key="u.id" style="display:flex;align-items:center;justify-content:space-between;margin:4px 0;">
              <div style="display:flex;align-items:center;gap:8px;">
                <div class="unit" :style="{ backgroundColor: u.color }">{{ u.type }}</div>
                <div class="small">{{ u.id }}</div>
              </div>
              <div v-if="phase === 'chooseDefenderCasualties' || phase === 'chooseAttackerCasualties'">
                <input type="checkbox" class="unit-checkbox" :value="u.id" v-model="selectedCasualtiesDefender" />
              </div>
            </div>

            <div class="small" style="margin-top:6px;">Defender Rolls:</div>
            <div class="dice">
              <div v-for="(d,i) in activeBattle.defenderRolls || []" :key="'d'+i" class="die">{{ d }}</div>
            </div>

            <div style="margin-top:8px;">
              <button class="btn btn-primary" :disabled="!canRoll('defender')" @click="rollDice('defender')">Roll Dice (Defender)</button>
            </div>
          </div>
        </div>

        <!-- Round results & casualty selection -->
        <div style="margin-top:12px;">
          <div class="small"><strong>Round:</strong> {{ activeBattle.round }}</div>
          <div class="small"><strong>Last round hits — AttackerHits:</strong> {{ activeBattle.lastAttackerHits || 0 }} — <strong>DefenderHits:</strong> {{ activeBattle.lastDefenderHits || 0 }}</div>

          <!-- defender chooses casualties -->
          <div v-if="phase === 'chooseDefenderCasualties'" style="margin-top:8px;">
            <div class="small">Defender: select <strong>{{ activeBattle.lastAttackerHits }}</strong> unit(s) to remove</div>
            <button class="btn btn-primary" :disabled="selectedCasualtiesDefender.length !== activeBattle.lastAttackerHits" @click="applyDefenderCasualties()">Confirm Defender Casualties</button>
          </div>

          <!-- attacker chooses casualties -->
          <div v-if="phase === 'chooseAttackerCasualties'" style="margin-top:8px;">
            <div class="small">Attacker: select <strong>{{ activeBattle.lastDefenderHits }}</strong> unit(s) to remove</div>
            <button class="btn btn-primary" :disabled="selectedCasualtiesAttacker.length !== activeBattle.lastDefenderHits" @click="applyAttackerCasualties()">Confirm Attacker Casualties</button>
          </div>

          <!-- End battle if resolved -->
          <div v-if="phase === 'resolved'" style="margin-top:12px;">
            <div class="small">Battle finished — winner: <strong>{{ activeBattle.winner }}</strong></div>
            <button class="btn btn-primary" @click="finishBattle()">Close & Apply Results</button>
          </div>

          <div style="margin-top:8px;">
            <button class="btn btn-danger" @click="abortBattle()" v-if="canAbort">Abort Battle</button>
            <div class="small" style="margin-top:6px;">(If you abort, the battle will be cancelled — for testing only)</div>
          </div>
        </div>

        <div style="margin-top:8px;">
          <h4>Battle Log</h4>
          <div v-for="(l,i) in activeBattle.log || []" :key="i" class="small">• {{ l }}</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const firebaseConfig = {
    apiKey: "AIzaSyAL4FGAaOfKPJfEkYGBUZN7dW5_XNfmoww",
    authDomain: "axisandallies-prototype.firebaseapp.com",
    projectId: "axisandallies-prototype",
    storageBucket: "axisandallies-prototype.firebasestorage.app",
    messagingSenderId: "663070828047",
    appId: "1:663070828047:web:9f37c0fc5541ff86d6657a"
  };
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.firestore();

  // same color function as before
  function colorForUser(email) {
    const colors = ["#fcba03", "#fc0303", "#fc0313", "#2403fc", "#000000", "#1f8f03"];
    let hash = 0;
    for (let i = 0; i < email.length; i++) hash = email.charCodeAt(i) + ((hash << 5) - hash);
    return colors[Math.abs(hash) % colors.length];
  }

  // hit thresholds
  const HIT_THRESHOLDS = { infantry: 2, tank: 3, artillery: 3, fighter: 4, bomber: 4 };
  function rollDie() { return Math.floor(Math.random()*6)+1; }

  const app = Vue.createApp({
    data() {
      return {
        user: null,
        email: '',
        password: '',
        map: {},
        selected: null,
        territoryOrder: ["A","B","C","D","E","F","G","H","I","J"],
        unitTypes: ["infantry","tank","artillery","fighter","bomber"],
        selectedUnitType: "infantry",
        activeBattle: null,         // live battle object synced from Firestore
        battleSummaryLog: [],       // short log visible outside modal
        // UI selections for choosing casualties
        selectedCasualtiesDefender: [],
        selectedCasualtiesAttacker: []
      };
    },
    computed: {
      phase() {
        if (!this.activeBattle) return null;
        return this.activeBattle.phase;
      },
      canAbort() {
        if (!this.activeBattle) return false;
        // allow abort only for participants for testing
        return this.user && (this.user.email === this.activeBattle.attackerEmail || this.user.email === this.activeBattle.defenderEmail);
      }
    },
    methods: {
      async login() {
        try { await auth.signInWithEmailAndPassword(this.email, this.password); }
        catch (e) { await auth.createUserWithEmailAndPassword(this.email, this.password); }
      },

      // Create or init map doc on first login
      async ensureMapInitialized() {
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        if (!snap.exists) {
          const newMap = {};
          this.territoryOrder.forEach(id => newMap[id] = { units: [] });
          await ref.set({ map: newMap });
        } else {
          const data = snap.data();
          let changed = false;
          this.territoryOrder.forEach(id => {
            if (!data.map[id]) { data.map[id] = { units: [] }; changed = true; }
          });
          if (changed) await ref.update({ map: data.map });
        }
      },

      // When clicking on territory: select / place / attempt move
      async handleTerritoryClick(id) {
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        const data = snap.data();
        if (!data.map[id]) data.map[id] = { units: [] };

        if (this.selected) {
          // attempt to move unit from selected.from to id
          const fromId = this.selected.from;
          const unit = this.selected.unit;

          // if destination has enemy units -> start interactive battle
          const destUnits = (data.map[id].units || []);
          const enemies = destUnits.filter(u => u.owner !== this.user.email);

          // Remove the unit from the origin now (we keep it in data until battle resolves)
          data.map[fromId].units = data.map[fromId].units.filter(u => u.id !== unit.id);

          if (enemies.length > 0) {
            // create activeBattle object in the doc so both players see modal
            const battleObj = {
              territory: id,
              attackerEmail: this.user.email,
              defenderEmail: enemies[0].owner,                // defender owner (first enemy)
              attackerUnits: [unit],                          // only moving unit initiates
              defenderUnits: destUnits.slice(),               // copy current defenders
              round: 1,
              phase: "awaitingAttackerRoll",                  // phases: awaitingAttackerRoll -> chooseDefenderCasualties -> awaitingAttackerRoll (next round) or awaitingDefenderRoll etc.
              attackerRolls: [],
              defenderRolls: [],
              lastAttackerHits: 0,
              lastDefenderHits: 0,
              log: [ `Battle created at ${id}: attacker ${this.user.email} vs defender ${enemies[0].owner}` ],
              winner: null
            };

            // write the battle into the doc and also remove the unit from fromId (we already removed above)
            data.activeBattle = battleObj;
            await ref.update({ map: data.map, activeBattle: battleObj });
            // selected cleared (battle modal will allow moves)
            this.selected = null;
            return;
          } else {
            // no enemies → simple move
            data.map[id].units.push(unit);
            this.selected = null;
            await ref.update({ map: data.map });
            return;
          }
        } else {
          // select a unit if it's yours; otherwise place chosen unit
          const territory = data.map[id];
          const ownUnit = (territory.units || []).find(u => u.owner === this.user.email);
          if (ownUnit) {
            this.selected = { from: id, unit: ownUnit };
            return;
          } else {
            // place unit
            const newUnit = { id: Date.now(), type: this.selectedUnitType, owner: this.user.email, color: colorForUser(this.user.email) };
            territory.units.push(newUnit);
            await ref.update({ map: data.map });
            return;
          }
        }
      },

      // can the current user roll for given side?
      canRoll(side) {
        if (!this.activeBattle || !this.user) return false;
        if (this.phase === 'awaitingAttackerRoll' && side === 'attacker') {
          return this.user.email === this.activeBattle.attackerEmail;
        }
        if (this.phase === 'awaitingDefenderRoll' && side === 'defender') {
          return this.user.email === this.activeBattle.defenderEmail;
        }
        return false;
      },

      // roll dice for the side (attacker or defender)
      async rollDice(side) {
        if (!this.activeBattle) return;
        const ref = db.doc("games/demoGame");
        // fetch latest doc to avoid conflicts
        const snap = await ref.get();
        const data = snap.data();
        const b = data.activeBattle;
        if (!b) return;

        // compute rolls and hits
        if (side === 'attacker' && b.phase === 'awaitingAttackerRoll') {
          const rolls = b.attackerUnits.map(u => rollDie());
          const hits = rolls.reduce((acc, r, i) => acc + (r <= (HIT_THRESHOLDS[b.attackerUnits[i].type] || 0) ? 1 : 0), 0);
          b.attackerRolls = rolls;
          b.lastAttackerHits = hits;
          b.log.push(`Round ${b.round}: Attacker rolled [${rolls.join(', ')}] -> ${hits} hit(s)`);
          // next phase: defender chooses casualties
          b.phase = 'chooseDefenderCasualties';
        } else if (side === 'defender' && b.phase === 'awaitingDefenderRoll') {
          const rolls = b.defenderUnits.map(u => rollDie());
          const hits = rolls.reduce((acc, r, i) => acc + (r <= (HIT_THRESHOLDS[b.defenderUnits[i].type] || 0) ? 1 : 0), 0);
          b.defenderRolls = rolls;
          b.lastDefenderHits = hits;
          b.log.push(`Round ${b.round}: Defender rolled [${rolls.join(', ')}] -> ${hits} hit(s)`);
          // next phase: attacker chooses casualties
          b.phase = 'chooseAttackerCasualties';
        } else {
          return; // invalid call
        }

        // write back
        await ref.update({ activeBattle: b });
      },

      // Defender chooses casualties equal to lastAttackerHits
      async applyDefenderCasualties() {
        if (!this.activeBattle) return;
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        const data = snap.data();
        const b = data.activeBattle;
        if (!b) return;

        const hits = b.lastAttackerHits || 0;
        // validate selection
        if (this.selectedCasualtiesDefender.length !== hits) {
          alert(`Select exactly ${hits} unit(s).`);
          return;
        }
        // remove selected from defenderUnits
        b.defenderUnits = b.defenderUnits.filter(u => !this.selectedCasualtiesDefender.includes(String(u.id)));
        b.log.push(`Defender removed ${hits} unit(s): ${this.selectedCasualtiesDefender.join(', ')}`);
        this.selectedCasualtiesDefender = [];

        // check victory
        if (b.defenderUnits.length === 0) {
          b.winner = 'attacker';
          b.phase = 'resolved';
          b.log.push(`Attacker wins the battle!`);
          // write and let finishBattle apply map changes
          await ref.update({ activeBattle: b });
          return;
        }

        // Next: defender rolls (defender's attack for round)
        b.phase = 'awaitingDefenderRoll';
        await ref.update({ activeBattle: b });
      },

      // Attacker chooses casualties equal to lastDefenderHits
      async applyAttackerCasualties() {
        if (!this.activeBattle) return;
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        const data = snap.data();
        const b = data.activeBattle;
        if (!b) return;

        const hits = b.lastDefenderHits || 0;
        if (this.selectedCasualtiesAttacker.length !== hits) {
          alert(`Select exactly ${hits} unit(s).`);
          return;
        }
        b.attackerUnits = b.attackerUnits.filter(u => !this.selectedCasualtiesAttacker.includes(String(u.id)));
        b.log.push(`Attacker removed ${hits} unit(s): ${this.selectedCasualtiesAttacker.join(', ')}`);
        this.selectedCasualtiesAttacker = [];

        // check attacker eliminated
        if (b.attackerUnits.length === 0) {
          b.winner = 'defender';
          b.phase = 'resolved';
          b.log.push(`Defender wins the battle!`);
          await ref.update({ activeBattle: b });
          return;
        }

        // Next round: increment round and go to awaitingAttackerRoll
        b.round = (b.round || 1) + 1;
        b.attackerRolls = [];
        b.defenderRolls = [];
        b.lastAttackerHits = 0;
        b.lastDefenderHits = 0;
        b.phase = 'awaitingAttackerRoll';
        await ref.update({ activeBattle: b });
      },

      // When the battle resolves, apply results to map and archive the battle to history
      async finishBattle() {
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        const data = snap.data();
        const b = data.activeBattle;
        if (!b) return;

        // apply survivors to territory map
        if (b.winner === 'attacker') {
          // attacker controls territory: replace with attackerUnits (survivors)
          data.map[b.territory].units = (b.attackerUnits || []).map(u => ({...u}));
        } else if (b.winner === 'defender') {
          data.map[b.territory].units = (b.defenderUnits || []).map(u => ({...u}));
        } else {
          // in draw, combine survivors (unlikely with current flow)
          data.map[b.territory].units = (b.attackerUnits || []).concat(b.defenderUnits || []);
        }

        // archive battle
        data.battleHistory = data.battleHistory || [];
        data.battleHistory.unshift({ at: new Date().toISOString(), summary: b.log.join(' | '), raw: b });

        // remove activeBattle
        delete data.activeBattle;

        await ref.update({ map: data.map, battleHistory: data.battleHistory, activeBattle: firebase.firestore.FieldValue.delete() });

        // update local logs
        this.battleSummaryLog.unshift(`Battle at ${b.territory}: ${b.winner}`);
      },

      // abort battle (testing)
      async abortBattle() {
        if (!this.canAbort) { alert("Only participants can abort."); return; }
        const ref = db.doc("games/demoGame");
        const snap = await ref.get();
        const data = snap.data();
        delete data.activeBattle;
        await ref.update({ activeBattle: firebase.firestore.FieldValue.delete(), map: data.map });
      }
    },

    mounted() {
      auth.onAuthStateChanged(async (u) => {
        this.user = u;
        if (u) await this.ensureMapInitialized();
      });

      // Listen to map + activeBattle live
      db.doc("games/demoGame").onSnapshot(snap => {
        if (!snap.exists) return;
        const data = snap.data();
        this.map = data.map || {};
        this.activeBattle = data.activeBattle || null;
        // normalize attacker/defender unit ids to strings for selection binding
        if (this.activeBattle) {
          this.activeBattle.attackerUnits = (this.activeBattle.attackerUnits || []).map(u => ({...u, id: String(u.id)}));
          this.activeBattle.defenderUnits = (this.activeBattle.defenderUnits || []).map(u => ({...u, id: String(u.id)}));
        }
      });
    }
  });

  app.mount('#app');
</script>
</body>
</html>
